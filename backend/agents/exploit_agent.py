"""Exploit Simulation Agent â€” Simulates exploitation and generates Proof-of-Exploit scripts."""

import json
from typing import Any, Dict, List

from agents.base_agent import BaseAgent
from utils.llm_client import get_llm_response
from db.redis_client import update_scan_progress

SYSTEM_PROMPT = """You are an expert penetration tester and exploit developer. Given a vulnerability, you must:

1. Explain the exact exploitation steps an attacker would take
2. Generate a Proof-of-Exploit (PoE) script demonstrating the vulnerability
3. Describe the potential impact if exploited
4. Map the attack path from entry point to exploitation outcome

The PoE script should be educational and demonstrate the vulnerability concept.
Use Python for exploit scripts. Include comments explaining each step.

Output valid JSON:
{
    "exploits": [
        {
            "vulnerability_title": "...",
            "file_path": "...",
            "exploitation_steps": ["Step 1", "Step 2", "..."],
            "proof_of_exploit": "Python script as string",
            "impact_description": "What happens if exploited",
            "prerequisites": ["What attacker needs"],
            "attack_complexity": "Low|Medium|High",
            "attack_path": [
                {"node": "Entry Point", "type": "entry_point", "description": "..."},
                {"node": "Vulnerable Function", "type": "function", "description": "..."},
                {"node": "Data Store", "type": "database", "description": "..."},
                {"node": "Exploit Outcome", "type": "exploit_outcome", "description": "..."}
            ]
        }
    ]
}"""


class ExploitSimulationAgent(BaseAgent):
    name = "exploit_simulation_agent"
    description = "Simulates exploitation and generates Proof-of-Exploit scripts"

    async def run(self, state: Dict[str, Any]) -> Dict[str, Any]:
        project_id = state["project_id"]
        vulns = state.get("vulnerabilities", [])
        files = state.get("files", [])

        if not vulns:
            await self.log(project_id, "No vulnerabilities to simulate exploits for")
            state["exploits"] = []
            return state

        await self.log(project_id, f"Generating exploit simulations for {len(vulns)} vulnerabilities")
        await update_scan_progress(project_id, "exploit", self.name, 0.1, "Simulating exploits...")

        # Focus on high-severity vulnerabilities
        priority_vulns = sorted(
            vulns,
            key=lambda v: {"Critical": 4, "High": 3, "Medium": 2, "Low": 1}.get(v.get("severity", "Low"), 0),
            reverse=True,
        )[:10]  # Top 10

        # Get relevant file content for context
        file_context = self._get_relevant_files(priority_vulns, files)

        user_prompt = f"""Generate exploit simulations for these vulnerabilities:

VULNERABILITIES:
{json.dumps(priority_vulns, indent=2, default=str)}

RELEVANT CODE CONTEXT:
{file_context}

For each vulnerability:
1. Create a realistic Proof-of-Exploit script
2. Map the complete attack path
3. Describe the impact in business terms"""

        try:
            response = await get_llm_response(SYSTEM_PROMPT, user_prompt, json_mode=True, max_tokens=4096)
            exploit_results = json.loads(response)
            exploits = exploit_results.get("exploits", [])
        except Exception as e:
            # await self.log(project_id, f"Exploit simulation error: {str(e)}", "warning")
            pass
            exploits = self._generate_basic_exploits(priority_vulns)

        await self.save_output(project_id, {"exploits": exploits})
        await self.log(project_id, f"Exploit simulation complete: {len(exploits)} PoE scripts generated", "success")
        await update_scan_progress(project_id, "exploit", self.name, 1.0, "Exploit simulation complete")

        state["exploits"] = exploits
        return state

    def _get_relevant_files(self, vulns: List[Dict], files: List[Dict]) -> str:
        vuln_files = set(v.get("file_path", "") for v in vulns)
        parts = []
        for f in files:
            if f["file_path"] in vuln_files:
                content = f.get("content", "")[:2000]
                parts.append(f"=== {f['file_path']} ===\n{content}")
        return "\n\n".join(parts[:10])

    def _generate_basic_exploits(self, vulns: List[Dict]) -> List[Dict]:
        """Generate basic exploit descriptions as fallback."""
        exploits = []
        for v in vulns:
            exploit = {
                "vulnerability_title": v.get("title", "Unknown"),
                "file_path": v.get("file_path", ""),
                "exploitation_steps": [
                    f"Identify the {v.get('vulnerability_type', 'vulnerability')} in {v.get('file_path', 'target file')}",
                    "Craft malicious input targeting the vulnerable code",
                    "Send the payload through the identified entry point",
                    "Observe the impact of the exploit",
                ],
                "proof_of_exploit": f"# Proof of Exploit for: {v.get('title', 'Unknown')}\n# File: {v.get('file_path', '')}\n# This is a conceptual PoE\nimport requests\n\n# Target the vulnerable endpoint\n# Payload crafted for {v.get('vulnerability_type', 'the vulnerability')}\nprint('PoE script - see exploitation steps for details')",
                "impact_description": f"Exploitation of {v.get('vulnerability_type', 'this vulnerability')} could lead to unauthorized access or data compromise",
                "prerequisites": ["Network access to the application"],
                "attack_complexity": "Medium",
                "attack_path": [
                    {"node": "User Input", "type": "entry_point", "description": "Attacker-controlled input"},
                    {"node": v.get("title", "Vulnerable Function"), "type": "function", "description": v.get("description", "")},
                    {"node": "Exploit Outcome", "type": "exploit_outcome", "description": "Security breach"},
                ],
            }
            exploits.append(exploit)
        return exploits
